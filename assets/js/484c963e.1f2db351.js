"use strict";(self.webpackChunkbesom_website=self.webpackChunkbesom_website||[]).push([[901],{7196:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"io","title":"Inputs and Outputs","description":"Outputs are the primary asynchronous data structure of Pulumi programs.","source":"@site/docs/io.md","sourceDirName":".","slug":"/io","permalink":"/besom/docs/io","draft":false,"unlisted":false,"editUrl":"https://github.com/VirtusLab/besom/tree/main/website/docs/io.md","tags":[],"version":"current","frontMatter":{"title":"Inputs and Outputs"},"sidebar":"docsSidebar","previous":{"title":"Exports","permalink":"/besom/docs/exports"},"next":{"title":"Resource constructors","permalink":"/besom/docs/constructors"}}');var o=n(4848),r=n(8453);const a={title:"Inputs and Outputs"},i=void 0,c={},l=[{value:"Outputs",id:"outputs",level:3},{value:"Inputs",id:"inputs",level:3}];function u(e){const t={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["Outputs are the ",(0,o.jsx)(t.a,{href:"/besom/docs/basics#inputs-and-outputs",children:"primary asynchronous data structure of Pulumi"})," programs."]}),"\n",(0,o.jsx)(t.h3,{id:"outputs",children:"Outputs"}),"\n",(0,o.jsx)(t.p,{children:"Outputs are:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["pure and lazy - meaning that they suspend evaluation of code until interpretation, which is perfomed by Besom\nruntime that runs ",(0,o.jsx)(t.code,{children:"Pulumi.run"})," function at the, so called, end-of-the-world."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["monadic - meaning that they expose ",(0,o.jsx)(t.code,{children:"map"})," and ",(0,o.jsx)(t.code,{children:"flatMap"})," operators and can be used in for-comprehensions"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Outputs are capable of consuming other effects for which there exists an instance of ",(0,o.jsx)(t.code,{children:"ToFuture"})," typeclass. Besom\nprovides 3 such instances:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["package ",(0,o.jsx)(t.code,{children:"besom-core"})," provides an instance for ",(0,o.jsx)(t.code,{children:"scala.concurrent.Future"})]}),"\n",(0,o.jsxs)(t.li,{children:["package ",(0,o.jsx)(t.code,{children:"besom-cats"})," provides an instance for ",(0,o.jsx)(t.code,{children:"cats.effect.IO"})]}),"\n",(0,o.jsxs)(t.li,{children:["package ",(0,o.jsx)(t.code,{children:"besom-zio"})," provides an instance for ",(0,o.jsx)(t.code,{children:"zio.Task"})]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"inputs",children:"Inputs"}),"\n",(0,o.jsxs)(t.p,{children:["Inputs are Besom types used wherever a value is expected to be provided by user primarily to ease the use of the\nconfiguration necessary for resource constructors to spawn infrastructure resources. Inputs allow user to provide both\nraw values, values that are wrapped in an ",(0,o.jsx)(t.code,{children:"Output"}),", both of the former or nothing at all when dealing with optional\nfields or even singular raw values or lists of values for fields that expect multiple values."]}),"\n",(0,o.jsxs)(t.p,{children:["To make this more digestable - the basic ",(0,o.jsx)(t.code,{children:"Input[A]"})," type is declared as:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"opaque type Input[+A] >: A | Output[A] = A | Output[A]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["and the ",(0,o.jsx)(t.code,{children:"Input.Optional[A]"})," variant is declared as:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"opaque type Optional[+A] >: Input[A | Option[A]] = Input[A | Option[A]]\n"})}),"\n",(0,o.jsx)(t.p,{children:"This allows for things like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"val int1: Input[Int] = 23\nval int2: Input[Int] = Output(23)\n// what if it's an optional value?\nval maybeInt1: Input.Optional[Int] = 23\nval maybeInt2: Input.Optional[Int] = None\nval maybeInt3: Input.Optional[Int] = Some(23)\n// yes, but also:\nval maybeInt4: Input.Optional[Int] = Output(23)\nval maybeInt5: Input.Optional[Int] = Output(Option(23))\nval maybeInt6: Input.Optional[Int] = Output(None)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This elastic and permissive model was designed to allow a more declarative style and facilitate the implicit\nparallelism of evaluation. In fact, Outputs are meant to be thought of as short pipelines that one uses\nto transform properties and values obtained from one resource to be used as argument for another. If you're\nused to the classic way of working with monadic programs with chains of ",(0,o.jsx)(t.code,{children:"flatMap"})," and ",(0,o.jsx)(t.code,{children:"map"})," or for-comprehensions\nthis might seem a bit odd to you - why would we take values wrapped in Outputs as arguments? The answer is: ",(0,o.jsx)(t.strong,{children:"previews!"})]}),"\n",(0,o.jsxs)(t.p,{children:["Outputs incorporate semantics of ",(0,o.jsx)(t.code,{children:"Option"})," to support Pulumi's preview / dry-run feature that allows one to see what\nchanges will be applied when the program is executed against the actual environment. This, however, means that Outputs\ncan short-circuit when a computed (provided by the engine) value is missing in dry-run and most properties on resources\nbelong to this category. It is entirely possible to structure a Besom program the same way one would structure a program\nthat uses Cats Effect IO or ZIO but once you ",(0,o.jsx)(t.code,{children:"flatMap"})," on an Output value that can be only obtained from actual environment\nshort-circuiting logic will kick in and all the subsequent ",(0,o.jsx)(t.code,{children:"flatMap"}),"/",(0,o.jsx)(t.code,{children:"map"})," steps will be skipped yielding a broken view\nof the changes that will get applied in your next change to the infrastructure. To avoid this problem it is highly\nrecommended to write Besom programs in a style highly reminiscent of direct style and use for-comprehensions only to transform\nproperties passed from configuration or declared resources to another resources. This way the graph of resources is fully\nknown in the dry-run phase and can be properly inspected. Full power of monadic composition should be reserved for situations\nwhere it is strictly necessary."]})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var s=n(6540);const o={},r=s.createContext(o);function a(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);