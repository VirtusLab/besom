"use strict";(self.webpackChunkbesom_website=self.webpackChunkbesom_website||[]).push([[837],{8309:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>D,contentTitle:()=>T,default:()=>R,frontMatter:()=>N,metadata:()=>r,toc:()=>O});const r=JSON.parse('{"id":"async","title":"Resource constructor asynchronicity","description":"Resources in Besom have an interesting property related to the fact that Pulumi\'s runtime is asynchronous.","source":"@site/docs/async.md","sourceDirName":".","slug":"/async","permalink":"/besom/docs/async","draft":false,"unlisted":false,"editUrl":"https://github.com/VirtusLab/besom/tree/main/website/docs/async.md","tags":[],"version":"current","frontMatter":{"title":"Resource constructor asynchronicity"},"sidebar":"docsSidebar","previous":{"title":"Resource constructors","permalink":"/besom/docs/constructors"},"next":{"title":"Laziness","permalink":"/besom/docs/laziness"}}');var s=n(4848),a=n(8453),o=n(6540),i=n(8215),c=n(7559),u=n(3104),l=n(6347),d=n(205),p=n(7485),h=n(1682),m=n(679);function f(e){return o.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function b(e){const{values:t,children:n}=e;return(0,o.useMemo)(()=>{const e=t??function(e){return f(e).map(({props:{value:e,label:t,attributes:n,default:r}})=>({value:e,label:t,attributes:n,default:r}))}(n);return function(e){const t=(0,h.XI)(e,(e,t)=>e.value===t.value);if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[t,n])}function y({value:e,tabValues:t}){return t.some(t=>t.value===e)}function g({queryString:e=!1,groupId:t}){const n=(0,l.W6)(),r=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,p.aZ)(r),(0,o.useCallback)(e=>{if(!r)return;const t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})},[r,n])]}function v(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,s=b(e),[a,i]=(0,o.useState)(()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!y({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find(e=>e.default)??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:s})),[c,u]=g({queryString:n,groupId:r}),[l,p]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,r]=(0,m.Dv)(t);return[n,(0,o.useCallback)(e=>{t&&r.set(e)},[t,r])]}({groupId:r}),h=(()=>{const e=c??l;return y({value:e,tabValues:s})?e:null})();(0,d.A)(()=>{h&&i(h)},[h]);return{selectedValue:a,selectValue:(0,o.useCallback)(e=>{if(!y({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),p(e)},[u,p,s]),tabValues:s}}var k=n(2303);const w={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function x({className:e,block:t,selectedValue:n,selectValue:r,tabValues:a}){const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,u.a_)(),l=e=>{const t=e.currentTarget,s=o.indexOf(t),i=a[s].value;i!==n&&(c(t),r(i))},d=e=>{let t=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const n=o.indexOf(e.currentTarget)+1;t=o[n]??o[0];break}case"ArrowLeft":{const n=o.indexOf(e.currentTarget)-1;t=o[n]??o[o.length-1];break}}t?.focus()};return(0,s.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},e),children:a.map(({value:e,label:t,attributes:r})=>(0,s.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:l,...r,className:(0,i.A)("tabs__item",w.tabItem,r?.className,{"tabs__item--active":n===e}),children:t??e},e))})}function j({lazy:e,children:t,selectedValue:n}){const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===n);return e?(0,o.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,s.jsx)("div",{className:"margin-top--md",children:r.map((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==n}))})}function A(e){const t=v(e);return(0,s.jsxs)("div",{className:(0,i.A)(c.G.tabs.container,"tabs-container",w.tabList),children:[(0,s.jsx)(x,{...t,...e}),(0,s.jsx)(j,{...t,...e})]})}function B(e){const t=(0,k.A)();return(0,s.jsx)(A,{...e,children:f(e.children)},String(t))}const S={tabItem:"tabItem_Ymn6"};function I({children:e,hidden:t,className:n}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,i.A)(S.tabItem,n),hidden:t,children:e})}const N={title:"Resource constructor asynchronicity"},T=void 0,D={},O=[];function V(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Resources in Besom have an interesting property related to the fact that Pulumi's runtime is asynchronous.\nOne could suspect that in following snippet resources are created sequentially due to monadic syntax:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'for \n  a <- aws.s3.Bucket("first")\n  b <- aws.s3.Bucket("second")\nyield ()\n'})}),"\n",(0,s.jsx)(t.p,{children:"This isn't true. Pulumi expects that a language SDK will declare resources as fast as possible. Due to this\nfact resource constructors return immediately after they spawn a Resource object. A resource object is just a\nplain case class with each property expressed in terms of Outputs. The work necessary for resolution of these\nproperties is executed asynchronously. In the example above both buckets will be created in parallel."}),"\n",(0,s.jsxs)(t.p,{children:["Given that a piece of code is worth more than a 1000 words, below you can find code snippets that explain these\nsemantics using known Scala technologies. In each of them ",(0,s.jsx)(t.code,{children:"Output"})," is replaced with a respective async datatype\nto explain what internals of Besom are actually doing when resource constructors are called (oversimplified a\nbit)."]}),"\n",(0,s.jsxs)(B,{children:[(0,s.jsx)(I,{value:"Future",label:"stdlib Future",default:!0,children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'// internal function, here just to represent types\ndef resolveResourceAsync(name: String, args: Args, promises: Promise[_]*): Future[Unit] = ???\n\n// resource definition\ncase class Bucket(bucket: Future[String])\nobject Bucket:\n  def apply(name: String, args: BucketArgs = BucketArgs()): Future[Bucket] = \n    // create a promise for bucket property\n    val bucketNamePromise = Promise[String]() \n    // kicks off async resolution of the resource properties\n    resolveResourceAsync(name, args, bucketNamePromise) \n    // returns immediately\n    Future.successful(Bucket(bucketNamePromise.future)) \n\n// this just returns a Future[Unit] that will be resolved immediately\nfor \n  a <- Bucket("first")\n  b <- Bucket("second")\nyield ()\n'})})}),(0,s.jsx)(I,{value:"ce",label:"Cats Effect IO",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'// internal function, here just to represent types\ndef resolveResourceAsync(name: String, args: Args, promises: Deferred[IO, _]*): IO[Unit] = ???\n\n// resource definition\ncase class Bucket(bucket: IO[String])\nobject Bucket:\n  def apply(name: String, args: BucketArgs = BucketArgs()): IO[Bucket] = \n    for \n      // create a deferred for bucket property\n      bucketNameDeferred <- Deferred[IO, String]() \n      // kicks off async resolution of the resource properties\n      _ <- resolveResourceAsync(name, args, bucketNameDeferred).start \n    yield Bucket(bucketNameDeferred.get) // returns immediately\n\n// this just returns a IO[Unit] that will be resolved immediately\nfor \n  a <- Bucket("first")\n  b <- Bucket("second")\nyield ()\n'})})}),(0,s.jsx)(I,{value:"zio",label:"ZIO",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'// internal function, here just to represent types\ndef resolveResourceAsync(name: String, args: Args, promises: Promise[_]*): Task[Unit] = ???\n\n// resource definition\ncase class Bucket(bucket: Task[String])\nobject Bucket:\n  def apply(name: String, args: BucketArgs = BucketArgs()): Task[Bucket] = \n    for \n      // create a promise for bucket property\n      bucketNamePromise <- Promise.make[Exception, String]() \n      // kicks off async resolution of the resource properties\n      _ <- resolveResourceAsync(name, args, bucketNameDeferred).fork \n    yield Bucket(bucketNameDeferred.await) // returns immediately\n\n// this just returns a Task[Unit] that will be resolved immediately\nfor \n  a <- Bucket("first")\n  b <- Bucket("second")\nyield ()\n'})})})]}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["A good observer will notice that all these computations started in a fire-and-forget fashion have to be awaited somehow\nand that is true. Besom does await for all spawned Outputs to be resolved before finishing the run via a built-in task\ntracker passed around in ",(0,s.jsx)(t.code,{children:"Context"}),"."]})}),"\n",(0,s.jsxs)(t.p,{children:["There is an explicit way to inform Pulumi engine that some of the resources have to be created, updated or\ndeleted sequentially. To do that, one has to pass ",(0,s.jsx)(t.a,{href:"https://www.pulumi.com/docs/concepts/options/",children:"resource options"}),"\nto adequate resource constructors with ",(0,s.jsx)(t.code,{children:"dependsOn"})," property set to resource to await for. Here's an example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'for \n  a <- Bucket("first")\n  b <- Bucket("second", BucketArgs(), opts(dependsOn = a))\nyield ()\n'})}),"\n",(0,s.jsxs)(t.p,{children:["There's also ",(0,s.jsx)(t.code,{children:"deletedWith"})," property that allows one to declare that some resources will get cleaned up when another\nresource is deleted and that trying to delete them ",(0,s.jsx)(t.em,{children:"after"})," that resource is deleted will fail. A good example of such\nrelationship might be Kubernetes, where deletion of a namespace takes down all resources that belong do that namespace."]}),"\n",(0,s.jsx)(t.p,{children:"This manual wiring is only necessary for cases when there are no data dependencies between defined resources. In a case\nlike this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-scala",children:'  val defaultMetadata = k8s.meta.v1.inputs.ObjectMetaArgs(\n    labels = Map("app" -> "my-app")\n  )\n\n  val deployment = k8s.apps.v1.Deployment(\n    name = "my-app-deployment",\n    k8s.apps.v1.DeploymentArgs(\n      metadata = defaultMetadata,\n      spec = k8s.apps.v1.inputs.DeploymentSpecArgs(\n        // removed for brevity\n      )\n    )\n  )\n\n  val service = k8s.core.v1.Service(\n    name = "my-app-service",\n    k8s.core.v1.ServiceArgs(\n      spec = k8s.core.v1.inputs.ServiceSpecArgs(\n        selector = appLabels,\n        // removed for brevity\n      ),\n      metadata = defaultMetadata\n    ),\n    opts(dependsOn = deployment)\n  )\n'})}),"\n",(0,s.jsxs)(t.p,{children:["there is no data dependency between kubernetes deployment and kubernetes service because kubernetes links these\nentities using labels. There's a guarantee that service points towards the correct deployment because a programming\nlanguage is being used and that allows to define a common constant value that is reused to define them. There is,\nhowever, no output property of Deployment used in definition of Service and therefore Pulumi engine can't infer\nthat it should actually wait with the creation of Service until Deployment is up. In such cases one can use\n",(0,s.jsx)(t.code,{children:"dependsOn"})," property to inform the engine about such a relationship between resources."]})]})}function R(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(V,{...e})}):V(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var r=n(6540);const s={},a=r.createContext(s);function o(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);